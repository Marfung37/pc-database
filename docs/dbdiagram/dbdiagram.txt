enum kicktable {
  srs
  srs_plus
  srsx
  srs180 // jstris
  tetrax
  asc
  ars
  none // no kick table
}

enum hold_type {
  any    // swap with any
  cyclic // swap in cycle and stop after going through all once
  none
}

enum status {
  processing
  completed
  failed
}

enum setup_type {
  regular
  qb
  oqb
}

table schema_metadata {
  version           text          [primary key]
  description       text          [not null]
  updated_at        timestamptz   [default: `now()`]
}

table setups {
  setup_id          setupid       [primary key, note: '12 hexdigits']
  pc                smallint      [not null, note: 'PC Number for 1-9']
  leftover          varchar(7)    [not null, note: 'Pieces left from bag. Only TILJSZO allowed']
  build             varchar(10)   [not null, note: 'Pieces used in setup. Only TILJSZO allowed']
  cover_pattern     text          [not null, note: 'Extended pieces notation for when setup is covered. Need not be perfect']
  type              setup_type    [not null, default: 'regular', note: 'Type of setup for regular, qb, or oqb']
  fumen             text          [not null, note: 'Fumen of the setup']
  solve_pattern     text          [note: 'Extended pieces notation used for solving. NULL if internal node in oqb']
  mirror            setupid       [note: 'References a setup_id for mirror setup']
  see               smallint      [not null, default: 7, note: 'Number of pieces that can be seen']
  hold              smallint      [not null, default: 1, note: 'Number of pieces that can be held']
  credit            text          [note: 'Credit for founder or innovator of setup']
}

table setup_translations {
  setup_id          setupid       [not null]
  language_code     varchar(2)    [not null, default: 'en']
  description       text          [note: 'General description about setup']
  cover_description text          [note: 'Description for when to use this setup']
  indexes {
    (setup_id, language_code)     [pk]
  }
}

table setup_oqb_paths {
  setup_id          setupid   [not null]
  oqb_path          ltree     [not null, unique, note: 'Materialized path of ids to this setup']
}

table setup_variants {
  variant_number    int           [not null, note: 'Variant number 1 indexed. Variant 0 is the entry in setups']
  setup_id          setupid       [not null, note: '12 hexdigits']
  build             varchar(10)   [not null, note: 'Pieces used in setup. Only TILJSZO allowed']
  fumen             text          [not null, note: 'Fumen of the setup']
  solve_pattern     text          [note: 'Extended pieces notation used for solving. NULL if internal node in oqb']

  Note: 'Setups where other pieces can be placed without affecting statistics'
}

table setup_sets {
  setup_id          setupid       [not null]
  set_id            int           [not null]
}

table sets {
  set_id           int           [primary key]
}

table set_tags {
  set_id           int           [not null]
  tag_id           int           [not null]
  order            smallint      [note: 'Value to depict which order the sets are when displayed where less is earlier']
}

table tags {
  tag_id          int            [primary key]
  name            text           [not null, note: 'Tag for categorizing']
}

table set_translations {
  set_id           int           [not null]
  language_code    varchar(2)    [not null, default: 'en']
  name             text          [not null, note: 'Name of the set']
  description      text          [not null, note: 'Description about the set']
  indexes {
    (set_id, language_code) [pk]
  }
}

table set_paths {
  set_id    int       [not null]
  set_path  ltree     [not null, unique, note: 'Materialized path of ids to this set']
}

table statistics {
  stat_id           uuid          [primary key, default: `gen_random_uuid()`]
  setup_id          setupid       [not null, note: '12 hexdigits']
  kicktable         kicktable     [not null]
  hold_type         hold_type     [not null, default: 'any', note: 'Structure how hold works']
  cover_data        bytea         [note: 'Bit string of what queues are covered from cover dependence. NULL if all covered']
  solve_percent     decimal(5, 2) [note: 'Solve percent. NULL if internal node in oqb']
  solve_fraction    fraction      [note: 'Precise solve fraction. NULL if internal node in oqb']
  all_solves        text          [note: 'All solves for the setup']
  minimal_solves    text          [note: 'Minimal set of solves. NULL if not created']
  true_minimal      bool          [note: 'Whether algorithm for minimal gurantees minimality']
  path_file         bool          [note: 'Whether path file exist. Follows [setup-id]-[kicktable].csvd.xz format']

  indexes {
    (setup_id, kicktable, hold_type) [unique]
  }
}

table save_data {
  save_data_id      uuid          [primary key, default: `gen_random_uuid()`]
  save_id           uuid          [not null]
  stat_id           uuid          [not null]
  save_percent      decimal(5, 2) [note: 'Save percent. NULL if multiple saves']
  save_fraction     fraction      [note: 'Precise save fraction. NULL if multiple saves']
  priority_save_percent   decimal(5, 2) [note: 'Array of percents for giving priority for saves. NULL if one save']
  priority_save_fraction  fraction      [note: 'Array of fraction for giving priority for saves. NULL if one save']
  all_solves        text          [note: 'All solves for save']
  minimal_solves    text          [note: 'Minimal set of solves for save']
  true_minimal      bool          [note: 'Whether algorithm for minimal gurantees minimality']
  status            status        [not null, note: 'Status of the populating data']
}

table saves {
  save_id           uuid          [primary key, default: `gen_random_uuid()`]
  save              text          [not null, note: 'Pieces saved for next PC for sfinder-saves']
  pc                smallint      [not null, note: 'PC Number for 1-9']
  importance        smallint      [not null, note: 'Level of importance this save is. Denotes which saves are shown above others']
  auto_populate     bool          [not null, default: false, note: 'Whether to automatically populate for all setups with this pc']
  gen_minimal       bool          [not null, default: false, note: 'When automatically populating, populate the minimal solves']
  gen_all_solves    bool          [not null, default: false, note: 'When automatically populating, populate all solves']
}

table save_translations {
  save_id          uuid           [not null]
  language_code    varchar(2)     [not null, default: 'en']
  name             text           [not null, note: 'Name of the save. Ex: One T or Two LJ']
  indexes {
    (save_id, language_code) [pk]
  }
}

table users {
  user_id          uuid         [primary key, default: `gen_random_uuid()`]
  auth_id          uuid         [unique]
  username         text         [unique, not null] // maybe should have credit reference this
  email            text         [unique, not null]
  editor           bool         [not null, default: false]
  admin            bool         [not null, default: false]
  active           bool         [not null, default: false]

  indexes {
    auth_id [name: "user_auth_id_idex", unique]
  }
}

table auth.users {
  id                uuid [primary key, ref: - users.auth_id]
  email             text [not null, unique]
}

Ref: statistics.setup_id > setups.setup_id        [delete: cascade, update: cascade]
Ref: save_data.stat_id > statistics.stat_id       [delete: cascade, update: cascade]
Ref: saves.save_id > save_data.save_id            [delete: cascade, update: cascade]

Ref: setup_variants.setup_id > setups.setup_id    [delete: cascade, update: cascade]
Ref: setup_oqb_paths.setup_id > setups.setup_id   [delete: cascade, update: cascade]
Ref: setups.mirror - setups.setup_id              [delete: cascade, update: cascade]

Ref: setup_sets.setup_id > setups.setup_id        [delete: cascade, update: cascade]
Ref: setup_sets.set_id > sets.set_id              [delete: cascade, update: cascade]
Ref: set_paths.set_id > sets.set_id               [delete: cascade, update: cascade]
Ref: set_tags.set_id > sets.set_id                [delete: cascade, update: cascade]
Ref: set_tags.tag_id > tags.tag_id                [delete: cascade, update: cascade]

Ref: save_translations.save_id > saves.save_id     [delete: cascade, update: cascade]
Ref: setup_translations.setup_id > setups.setup_id [delete: cascade, update: cascade]
Ref: set_translations.set_id > sets.set_id         [delete: cascade, update: cascade]

Ref: "public"."statistics"."solve_percent" < "public"."statistics"."setup_id"
