// if supporting different kicktables, need to support for different cover data also.

enum kicktable {
  srs
  srs_plus
  srsx
  srs180 // jstris
  tetrax
  asc
  ars
  none // no kick table
}

table setups {
  setup_id          setupid       [primary key, note: '5 bytes']
  leftover          varchar(7)    [not null, note: 'Pieces left from bag. Only TILJSZO allowed']
  build             varchar(10)   [not null, note: 'Pieces used in setup. Only TILJSZO allowed']
  cover_dependence  varchar(255)  [not null, note: 'Description of when setup is covered']
  cover_data        bytea         [note: 'Bit string of what queues are covered from cover dependence. 1 if all covered']
  oqb_path          varchar(131)  [note: 'Materialized path of ids to this setup. NULL if not oqb']
  oqb_depth         int           [note: 'Setup oqb tree depth']
  fumen             varchar(1000) [not null, note: 'Fumen of the setup']
  pieces            varchar(100)  [note: 'Pieces used for solving. NULL if intended as step to full setup']
  mirror            setupid       [note: '5 bytes and references an id for mirror setup']
  credit            varchar(255)  [note: 'Credit for founder of setup']
}

table setup_oqb_links {
  child_id          setupid   [primary key]
  parent_id         setupid   [not null]
}

table setup_variants {
  variant_id        int           [not null, note: 'Variant number 1 indexed']
  setup_id          setupid       [not null, note: '5 bytes']
  build             varchar(10)   [not null, note: 'Pieces used in setup. Only TILJSZO allowed']
  cover_dependence  varchar(255)  [not null, note: 'Description of when setup is covered']
  cover_data        bytea         [note: 'Bit string of what queues are covered from cover dependence. 1 if all covered']
  fumen             varchar(1000) [not null]
  pieces            varchar(100)  [note: 'Pieces used for solving. NULL if intended as step to full setup']

  Note: 'Setups where other pieces can be placed without affecting statistics'
}

table statistics {
  stat_id           uuid          [primary key, default: `gen_random_uuid()`]
  setup_id          setupid       [not null]
  kicktable         kicktable     [not null]
  solve_percent     decimal(5, 2) [note: 'Solve percent. NULL if intended as step to full setup']
  solve_fraction    fraction      [note: 'Percise solve fraction']
  minimal_solves    varchar(1000) [note: 'Minimal set of solves']
  path_file         varchar(20)  [note: 'Blob location of path.csv file']

  indexes {
    (setup_id, kicktable) [unique]
  }
}

table saves {
  save_id           uuid          [primary key, default: `gen_random_uuid()`]
  stat_id           uuid          [not null]
  save              varchar(255)  [not null, note: 'Pieces saved for next PC in extends pieces notation']
  description       varchar(255)  [note: 'Description of the save. Ex: One T or Two LJ']
  save_percent      decimal(5, 2) [not null, note: 'Save percent']
  save_fraction     fraction      [not null, note: 'Percise save fraction']
  minimal_solves    varchar(1000) [note: 'Minimal set of 1solves']
}

Ref: statistics.setup_id > setups.setup_id        [delete: cascade, update: cascade]
Ref: saves.stat_id > statistics.stat_id           [delete: cascade, update: cascade]
Ref: setup_variants.setup_id > setups.setup_id    [delete: cascade, update: cascade]
Ref: setup_oqb_links.child_id > setups.setup_id   [delete: cascade, update: cascade]
Ref: setup_oqb_links.parent_id > setups.setup_id  [delete: cascade, update: cascade]
Ref: setups.mirror - setups.setup_id 
